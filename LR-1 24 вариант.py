'''
Лабораторная работа №1
Написать программу, которая читая символы из бесконечной последовательности (эмулируется конечным файлом, читающимся поблочно), распознает,
преобразует и выводит на экран числа по определенному правилу.
Числа распознаются по законам грамматики русского языка. 
Преобразование делать по возможности через словарь.
Для упрощения под выводом числа прописью подразумевается последовательный вывод всех цифр числа. Регулярные выражения использовать нельзя.

Вариант 24.
Шеснадцатиричные числа, не превышающие 1024 расположенные в порядке убывания. Для каждой такой последовательности максимальное число вывести прописью.
'''

def check_hex(item):
    '''Проверяем является ли строка 16-ым числом не превышающим 1024'''
    try:
        if int(item, 16) <= 1024:
            return True
    except:
        return False

filename = 'test.txt'
#Файл для тестирования

replicate_dict = {'1': 'Один', '3':'Три', '5':'Пять', '7':'Семь', '9':'Девять', 'B':'Одиннадцать', 'D':'Тринадцать', 'F':'Пятнадцать', '0':'Ноль', '2':'Два', '4':'Четыре', '6':'Шесть', '8':'восемь', 'A':'Десять', 'C':'Двенадцать', 'E':'Четырнадцать'} #словарь для сопоставления цифры с её наименованием


with open(filename) as file:  #Открываем файл для чтения
    test_data = file.read().split() #Читаем файл целиком и разбиваем на слова

temp = [] #Список для хранения последовательностей
res = [] #Список для хранения найденных убывающих последовательностей
for i in range(len(test_data)): #Итерация по каждому слову в тексте
    if check_hex(test_data[i]): #Проверяем является ли слово 16 числом <1024
        try:    #Защита от обращения к несуществующему индексу
            t = temp[-1] #выбираем последний элемент в последовательности чисел для проверки с текущим числом
        except:
            t = test_data[i] #Если список пуст, то последним элементом этого списка будет проверяемое число
        if int(test_data[i], 16) <= int(t, 16): #Если проверяемое число меньше или равно последнему элементу в последовательности, то последовательность - убывающая и данное число добавляется в конец списка. Если temp путой, то роверяемое число будет сравниваться само с собой и таким образом станет первым элементом в temp
            temp.append(test_data[i])
        else: #если последовательность не убывающая, то добавляем полученную последовательность в результирующий список, даже если число ее элементов меньше 2
            res.append(temp)
            temp = [test_data[i]] #Теперь текущее число становится первым элементов новой последовательности
    else: #Если проверяемое слово - не число, подходящее по условиям, то добавляем имеющуюся последовательность в результирующий список
        res.append(temp)
        temp = [] #обнуляем последовательность
else: #Если все слова проверены, то добавляем последовательность в результирующий список
    res.append(temp)
 
for item in filter(lambda x:len(x)>1, res): #итерация по тем последовательностям длина которых больше 1
    print('_'.join(map(lambda x:replicate_dict[x], item[0])), end=' ') #Т.к. первый элемент убывающей последовательности - максимальный элемент, то выводим его прописью
    print(*item[1:], sep=' ') #Выводим оставшиеся элементы
    
